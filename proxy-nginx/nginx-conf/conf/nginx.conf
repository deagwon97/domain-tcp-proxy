
#user  nobody;
worker_processes  1;

#error_log  logs/error.log;
#error_log  logs/error.log  notice;
#error_log  logs/error.log  info;

#pid        logs/nginx.pid;


events {
    worker_connections  1024;
}




http {
    # Include Lua module and load other necessary Lua libraries
    lua_package_path "./?.lua;/usr/local/share/lua/5.1/?.lua;/usr/local/share/lua/5.1/?/init.lua;/usr/local/lib/lua/5.1/?.lua;/usr/local/lib/lua/5.1/?/init.lua;/usr/share/lua/5.1/?.lua;/usr/share/lua/5.1/?/init.lua
./?.so;/usr/local/lib/lua/5.1/?.so;/usr/lib/x86_64-linux-gnu/lua/5.1/?.so;/usr/lib/lua/5.1/?.so;/usr/local/lib/lua/5.1/loadall.so";
    lua_shared_dict my_cache 1m; # Optional caching

    server {
        listen 9980;
        access_log  /workdir/proxy-nginx/nginx-1.19.3/log/nginx.log;
        error_log   /workdir/proxy-nginx/nginx-1.19.3/log/error.log;

        location / {
            
            set $target_ip '';
            set $target_port '';

            proxy_http_version 1.1; 
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";
            proxy_read_timeout 86400;
            

            # Run the Lua code
            rewrite_by_lua_block {
                local blowfish = require "resty.nettle.blowfish"
                local hex = require "resty.string"
                

                local function from_hex(str)
                    return (str:gsub('..', function (cc)
                        return string.char(tonumber(cc, 16))
                    end))
                end

                local function from_hex(str)
                    return (str:gsub('..', function (cc)
                        return string.char(tonumber(cc, 16))
                    end))
                end

                local function decrypt(encrypted_hex, key)
                    local encrypted = from_hex(encrypted_hex)
                    local cipher = blowfish.new(key, "ecb") -- 여기서 "ecb" 모드를 사용합니다.
                    local decrypted = cipher:decrypt(encrypted)
                    return decrypted
                end

                local function split_ip_port(str)
                    local ip, port = str:match'(.-):(.*)'
                    return ip, port
                end

                local function decode(subdomain)
                    local decrypted_text = decrypt(subdomain, "thisissecretkey")
                    local appHost, appPort = split_ip_port(decrypted_text)
                    return appHost, appPort
                end

                -- Extract subdomain from host (Assuming the subdomain is the encrypted string)
                local subdomain = ngx.var.host:match("^(.-)%.")
                if subdomain then
                    local ip, port = decode(subdomain)
                    ngx.var.target_ip = ip
                    ngx.var.target_port = port
                else
                    return ngx.exit(400) -- Bad request if no subdomain found
                end

                
            }

            # Proxy to the decoded IP and port
            proxy_pass http://localhost:$target_port;
            proxy_set_header Host localhost:$target_port;
            
        }
    }



    # another virtual host using mix of IP-, name-, and port-based configuration
    #
    #server {
    #    listen       8000;
    #    listen       somename:8080;
    #    server_name  somename  alias  another.alias;

    #    location / {
    #        root   html;
    #        index  index.html index.htm;
    #    }
    #}


    # HTTPS server
    #
    #server {
    #    listen       443 ssl;
    #    server_name  localhost;

    #    ssl_certificate      cert.pem;
    #    ssl_certificate_key  cert.key;

    #    ssl_session_cache    shared:SSL:1m;
    #    ssl_session_timeout  5m;

    #    ssl_ciphers  HIGH:!aNULL:!MD5;
    #    ssl_prefer_server_ciphers  on;

    #    location / {
    #        root   html;
    #        index  index.html index.htm;
    #    }
    #}

}
